package main

import (
	"bufio"
	"context"
	"flag"
	"fmt"
	"os"
	"strings"
	"time"

	"golang.org/x/crypto/ssh/terminal"

	"github.com/chromedp/chromedp"
	"github.com/fatih/color"
	"github.com/sethvargo/go-password/password"
)

func main() {
	flag.Usage = usage
	var (
		// Things for command line arguments.
		username = flag.String(
			"username", "", "Username to login with.",
		)
		oldPassword = flag.String(
			"old-password", "", "Current password.",
		)
		updatePassword = flag.String(
			"new-password", "", "Updated password.",
		)
		autoGeneratePassword = flag.Bool(
			"auto-generate", false, "Generate a new password.")
		autoGenerateLen = flag.Int(
			"max-len",
			16,
			"auto-generate: The maximum length of the password.",
		)
		autoGenerateDigits = flag.Int(
			"num-digits",
			8,
			"auto-generate: The number of digits the password should contain.",
		)
		autoGenerateChars = flag.Int(
			"num-symbols",
			8,
			"auto-generate: The number of symbols the password should contain.",
		)
		autoGenerateUpper = flag.Bool(
			"no-upper",
			false,
			"auto-generate: Disable upper-case letter in the password.",
		)
		autoGenerateAllowRepeat = flag.Bool(
			"allow-repeat",
			false,
			"auto-generate: Allow repetitions in the password.",
		)
		tmpDir = flag.String(
			"tmp-dir",
			"nflx-passwd-rotate-tmpdir",
			"Temporary directory for user-data.",
		)
		devLogout = flag.Bool(
			"dev-logout",
			false,
			"Force logout from all devices.",
		)
		noColor = flag.Bool("no-color", false, "Disable color output.")
		outFile = flag.String(
			"out-file", "", "Write the new password to this file.",
		)

		// Things for interactive inputs.
		usrInt      bool
		oldPwInt    bool
		newPwInt    bool
		overrideInt bool

		rdr *bufio.Reader
		wtr *bufio.Writer

		// Things for the browser.
		err     error
		eval    bool
		evalStr string
		tasks   chromedp.Tasks

		execCtx context.Context
		bwsrCtx context.Context
		waitCtx context.Context

		execCancel context.CancelFunc
		bwsrCancel context.CancelFunc
		waitCancel context.CancelFunc

		login  = &netflixLogin{}
		update = &netflixPasswordUpdate{}

		// Misc.
		tmp    []byte
		errno  *int
		status int
		pwFile *os.File
	)

	errno = &status
	defer exit(errno)

	flag.Parse()

	rdr = bufio.NewReader(os.Stdin)

	if *noColor {
		color.NoColor = true
	}

	if *username == "" {
		usrInt = true
	}

	if *oldPassword == "" {
		oldPwInt = true
	}

	if *updatePassword == "" {
		newPwInt = true
	}

	if !newPwInt && *autoGeneratePassword {
		wrnColor(
			os.Stderr,
			"WRN: Conflicting options -- `new-password' (non-empty)"+
				" and `auto-generate'; choosing the latter.\n",
		)
		overrideInt = true
	}

	if overrideInt || *autoGeneratePassword {
		*updatePassword, err = password.Generate(
			*autoGenerateLen,
			*autoGenerateChars,
			*autoGenerateDigits,
			*autoGenerateUpper,
			*autoGenerateAllowRepeat,
		)
		if err != nil {
			// Fallback to interactive input.
			overrideInt = false

			errColor(
				os.Stderr,
				"ERR: Unable to auto-generate a new password.\n"+
					"ERR: %s\n",
				err,
			)
			*errno = errAutoFail
			return
		} else {
			if *outFile == "" {
				infColor(
					os.Stderr,
					"INF: Generated Password: \"%s\".\n",
					*updatePassword,
				)
			}
		}
	}

	if usrInt {
		inpColor(os.Stdout, "Netflix Username: ")
		*username, err = rdr.ReadString('\n')
		if err != nil {
			errColor(
				os.Stderr,
				"ERR: Unable to read the input string (%s).\n",
				err,
			)

			*errno = errFlagFail
			return
		}
		*username = strings.TrimSpace(*username)
	}

	if oldPwInt {
		inpColor(os.Stdout, "Netflix Password (for %s, current): ", *username)
		tmp, err = terminal.ReadPassword(int(os.Stdin.Fd()))
		if err != nil {
			errColor(
				os.Stderr,
				"ERR: Unable to read the input string (%s).\n",
				err,
			)

			*errno = errFlagFail
			return
		}
		*oldPassword = string(tmp)
		fmt.Println()
	}

	if !overrideInt && newPwInt {
		inpColor(os.Stdout, "Netflix Password (for %s, updated): ", *username)
		tmp, err = terminal.ReadPassword(int(os.Stdin.Fd()))
		if err != nil {
			errColor(
				os.Stderr,
				"ERR: Unable to read the input string (%s).\n",
				err,
			)

			*errno = errFlagFail
			return
		}
		*updatePassword = string(tmp)
		fmt.Println()

		inpColor(os.Stdout, "Netflix Password (for %s, confirm): ", *username)
		tmp, err = terminal.ReadPassword(int(os.Stdin.Fd()))
		if err != nil {
			errColor(
				os.Stderr,
				"ERR: Unable to read the input string (%s).\n",
				err,
			)
			*errno = errFlagFail
			return
		}
		fmt.Println()

		if string(tmp) != *updatePassword {
			errColor(os.Stderr, "ERR: Passwords do not match.\n")
			*errno = errFlagFail
			return
		}
	}

	// Create a temporary directory for user data.
	*tmpDir, err = mkTmpDir(*tmpDir)
	if err != nil {
		errColor(
			os.Stderr,
			"ERR: Unable to create a temporary directory (%s).\n",
			err,
		)

		*errno = errTmpFail
		return
	}
	defer os.RemoveAll(*tmpDir)

	// Create an execution alloator.
	execCtx, execCancel = genExecContext(*tmpDir)
	defer execCancel()

	// Add a wait context for timeouts.
	waitCtx, waitCancel = context.WithTimeout(
		execCtx, 4*netflixVerifyWait*time.Second,
	)
	defer waitCancel()

	// This is the main context for the browser.
	bwsrCtx, bwsrCancel = chromedp.NewContext(waitCtx)
	defer bwsrCancel()

	// Get the login credentials.
	login.loadLoginParams(*username, *oldPassword)

	// Get the list of actions for login.
	tasks = loginActions(login)

	// Login to Netflix.
	err = exec(bwsrCtx, tasks)
	if err != nil {
		errColor(os.Stderr, "ERR: Browser execution failed (%s).\n", err)

		*errno = errExecFail
		return
	}

	// Check if the login works.
	evalStr, eval = getFailureReason(bwsrCtx, "login")
	if eval {
		errColor(os.Stderr, "ERR: %s\n", evalStr)

		*errno = errVerifyFail
		return
	} else {
		eval, err = jsEval(
			bwsrCtx, fmt.Sprintf(netflixEval, login.evalXpath, " === null"),
		)
		if err != nil {
			errColor(
				os.Stderr,
				"ERR: Netflix login verification failed (%s).\n",
				err,
			)

			*errno = errVerifyFail
			return
		}
		if !eval {
			errColor(os.Stderr, "ERR: Netflix login failed.\n")

			*errno = errLoginFail
			return
		}
	}

	// Get the update credentials.
	update.loadUpdateParams(*oldPassword, *updatePassword, *devLogout)

	// Get the list of actions for update.
	tasks = updateActions(update)

	// Update the password.
	err = exec(bwsrCtx, tasks)
	if err != nil {
		errColor(os.Stderr, "ERR: Browser execution failed (%s).\n", err)

		*errno = errExecFail
		return
	}

	// Check if the update worked.
	evalStr, eval = getFailureReason(bwsrCtx, "update")
	if eval {
		errColor(os.Stderr, "ERR: %s\n", evalStr)

		*errno = errVerifyFail
		return
	} else {
		eval, err = jsEval(
			bwsrCtx, fmt.Sprintf(netflixEval, update.evalXpath, " !== null"),
		)
		if err != nil {
			errColor(
				os.Stderr,
				"ERR: Netflix password update verification failed (%s).\n",
				err,
			)

			*errno = errVerifyFail
			return
		}
		if !eval {
			errColor(os.Stderr, "ERR: Password update failed.\n")

			*errno = errUpdateFail
			return
		}
	}

	// Write the new password to a file.
	if *outFile != "" {
		infColor(
			os.Stdout, "INF: Writing the new password to: \"%s\".\n", *outFile,
		)
		pwFile, err = os.Create(*outFile)
		if err != nil {
			errColor(
				os.Stderr,
				"ERR: Unable to open file for writing (%s).\n",
				err,
			)

			*errno = errWriteFail
			return
		}
		defer pwFile.Close()

		wtr = bufio.NewWriter(pwFile)
		_, err = wtr.WriteString(*updatePassword + "\n")
		if err != nil {
			errColor(
				os.Stderr,
				"ERR: Unable to write password to file (%s)\n",
				err,
			)

			*errno = errWriteFail
			return
		}
		wtr.Flush()
	}

	okColor(
		os.Stdout,
		"INF: The password for Netflix was updated successfully!\n",
	)
}
